# Continuous Integration / Continuous Delivery
name: CI/CD Pipeline
on:
  push:
    branches:
      - "*"
      # do not do CI on 'release' and 'develop' branches
      - '!release'
      - '!develop'
    tags:
      - v*.*.*
env:
  ##### JOB ON/OFF SWITCHES - Top/1st level overrides #####
  RUN_UNIT_TESTS: "true"
  DOCS_ON: "true"
  ###############################

  #### DOCS Build/Test ####
  ALWAYS_DOCS: "false"
  DOCS_JOB_POLICY: '2'  # {2, 3}
  DOCS_BUILDER_RUNTIME: "3.10"
  ##########################

jobs:
  # we use the below to read the workflow env vars and be able to use in "- if:" Job conditionals
  # now we can do -> if: ${{ needs.set_github_outputs.outputs.TESTS_ENABLED == 'true' }}
  # github does not have a way to simply do "- if: ${{ env.RUN_UNIT_TESTS == 'true' }} " !!
  set_github_outputs:
    name: Read Workflow Env Section Vars and set Github Outputs
    runs-on: ubuntu-latest
    steps:
      - name: Pass 'env' section variables to GITHUB_OUTPUT
        id: pass-env-to-output
        run: |
          # set the matrix strategy to Full Matrix Stress Test if on master/main or stress-test branch or any tag
          BRANCH_NAME=${GITHUB_REF_NAME}
          if [[ $BRANCH_NAME == "stress-test" || $GITHUB_REF == refs/tags/* ]]; then
            echo "matrix=$FULL_MATRIX_STRATEGY" >> $GITHUB_OUTPUT
          else
            echo "matrix=$UBUNTU_PY310_STRATEGY" >> $GITHUB_OUTPUT
          fi
          echo "TESTS_ENABLED=$RUN_UNIT_TESTS" >> $GITHUB_OUTPUT
          echo "PUBLISH_ON_PYPI=$PUBLISH_ON_PYPI" >> $GITHUB_OUTPUT
      ## Docker - Pipeline Settings ##
      - id: derive_docker_policy
        run: echo "POL=${{ (env.DOCKER_JOB_ON != 'true' && '0') || (env.ALWAYS_BUILD_N_PUBLSIH_DOCKER == 'true' && '1') || (env.DOCKER_JOB_POLICY == 'CDeployment' && '2') || (env.DOCKER_JOB_POLICY == 'CDelivery' && '3') }}" >> $GITHUB_OUTPUT
      ## Static Code Analysis - Pipeline Settings ##
      - id: derive_sqa_policy
        run: echo "POL=${{ (env.RUN_LINT_CHECKS != 'true' && '0') || (env.ALWAYS_LINT == 'true' && '1') || env.LINT_JOB_POLICY }}" >> $GITHUB_OUTPUT
      - id: read_sqa_py
        run: echo SQA_PY=${{ env.STATIC_ANALYSIS_PY }} >> $GITHUB_OUTPUT
      - id: read_pylint_baseline_score
        run: echo PYLINT_BASELINE_SCORE=${{ env.PYLINT_SCORE_THRESHOLD }} >> $GITHUB_OUTPUT
      ## Docs Build/Test - Pipeline Settings ##
      - id: derive_docs_policy
        run: echo "POL=${{ (env.DOCS_ON != 'true' && '0') || (env.ALWAYS_DOCS == 'true' && '1') || env.DOCS_JOB_POLICY }}" >> $GITHUB_OUTPUT
      - id: read_docs_py
        run: echo DOCS_PY=${{ env.DOCS_BUILDER_RUNTIME }} >> $GITHUB_OUTPUT
      ## Code Visualization - Pipeline Settings ##
      - id: derive_code_viz_policy
        run: echo "POL=${{ (env.DRAW_DEPENDENCIES != 'true' && '0') || (env.ALWAYS_CODE_VIZ == 'true' && '1') || env.CODE_VIZ_POLICY }}" >> $GITHUB_OUTPUT
    outputs:
      matrix: ${{ steps.pass-env-to-output.outputs.matrix }}
      TESTS_ENABLED: ${{ steps.pass-env-to-output.outputs.TESTS_ENABLED }}
      PUBLISH_ON_PYPI: ${{ steps.pass-env-to-output.outputs.PUBLISH_ON_PYPI }}
    ## Docker - Pipeline Settings ##
      PIPE_DOCKER_POLICY: ${{ steps.derive_docker_policy.outputs.POL }}
    ## Static Code Analysis - Pipeline Settings ##
      PIPE_SQA_POLICY: ${{ steps.derive_sqa_policy.outputs.POL }}
      PIPE_SQA_PY: ${{ steps.read_sqa_py.outputs.SQA_PY }}
      PIPE_SQA_PYLINT_PASS_SCORE: ${{ steps.read_pylint_baseline_score.outputs.PYLINT_BASELINE_SCORE }}
    ## Docs Build/Test - Pipeline Settings ##
      PIPE_DOCS_POLICY: ${{ steps.derive_docs_policy.outputs.POL }}
      PIPE_DOCS_PY: ${{ steps.read_docs_py.outputs.DOCS_PY }}
    ## Code Visualization - Pipeline Settings ##
      PIPE_CODE_VIZ_POLICY: ${{ steps.derive_code_viz_policy.outputs.POL }}

  ### TEST Action returns 'false' (no Rules failed) in various End-2-End Scenarios ###
  test:
    if: vars.OVERRIDE_UNIT_TESTS == 'true' || vars.OVERRIDE_UNIT_TESTS != 'false'
    uses: ./.github/workflows/_test.yml
    with:
      test_matrix: |
        {
          "test_data": [
            {
              "name": "Test 'false' is returned, when Changelog is Updated according to the Rules",
              "changelog": "CHANGELOG.md",
              "version_to_check": "1.0.0",
              "expected_return_value": "false"
            }
          ]
        }

  ### TEST Action returns 'true' (some Rule failed) in various End-2-End Scenarios ###
  test_false:
    if: vars.OVERRIDE_UNIT_TESTS == 'true' || vars.OVERRIDE_UNIT_TESTS != 'false'
    uses: ./.github/workflows/_test_action_returns_false.yml
    with:
      test_matrix: |
        {
          "test_data": [
            {
              "name": "Test 'true' is returned, when Changelog is NOT Updated",
              "changelog": "CHANGELOG.md",
              "version_to_check": "1.0.0",
              "expected_return_value": "true"
            },
            {
              "name": "Test 'true' is returned, if Changelog does NOT exist",
              "changelog": "NON-EXISTING-CHANGELOG.md",
              "version_to_check": "1.0.0",
              "expected_return_value": "true"
            },
            {
              "name": "Test 'true' is returned, if Changelog is missing Sem Ver Section",
              "changelog": "CHANGELOG.md",
              "emulated_changelog_markdown_section": "## v0.5.0",
              "version_to_check": "1.0.0",
              "expected_return_value": "true"
            },
            {
              "name": "Test 'true' is returned, if Changelog is missing Sem Ver Section",
              "changelog": "CHANGELOG.md",
              "emulated_changelog_markdown_section": "## v0.5.0",
              "version_to_check": "1.0.0",
              "expected_return_value": "true"
            }
          ]
        }

  ### DOCS BUILD/TEST - DOCUMENTATION SITE ###
  docs:
    # IF PIPE_DOCS_POLICY != 0, will trigger by processing rules in order till TRUE
    # - PIPE_DOCS_POLICY == 1
    # - push event on 'main' branch AND PIPE_DOCS_POLICY == 2
    # - push event of "v*" tag AND PIPE_DOCS_POLICY == 2
    # - Documentation Changes Detected
    name: Build Documentation
    needs: set_github_outputs
    uses: boromir674/automated-workflows/.github/workflows/policy_docs.yml@v1.13.1
    with:
      run_policy: '${{ needs.set_github_outputs.outputs.PIPE_DOCS_POLICY }}'
      python_version: ${{ needs.set_github_outputs.outputs.PIPE_DOCS_PY }}
      dedicated_branches: 'main, release'  # 
      command: 'tox -s false -e pin-deps -- -E docs && tox -e docs --sitepackages -vv -s false'

  ### CI Checks - Quality Logic Gate ###
  quality_gate:
    # This Workflow implements both CI and CD, with its Jobs.
    # So we put the Quality Gate for Dynamic Acceptance/Check here, which should be wired up to the CI Jobs.
    if: always()
    needs: ['test', 'test_false', 'docs']
    uses: boromir674/automated-workflows/.github/workflows/go-single-status.yml@v1.13.1
    with:
      # leverage inputs to dynamically control the Acceptance Criteria
      # by default all job.needs Jobs must be Green

      # - This Gate can be used as an abstraction between CI and CD
      # - This Gate can be used as an abstraction CI Checks and Branch Protection Rules.Required_Checks

      # allowed-failures: docs, linters
      # CASE 1: when this Workflow only runs the CI part (no deploy) then
      # we want this Job to not affect the Green/Red Github Workflow Status.
      # So in this case we dynamically add whatever skipped Jobs from Overrides to the 'allowed-skips'
      # CASE 2: when the CD part of the Pipeline also runs that means that we are etiher on release
      # or main branch, and/or on an PR. So, in this case we want to enforce all job.needs to
      # be GREEN, so we simply pass only jobs: ${{ toJSON(needs) }}
      # allowed-skips: ${{ needs.*.result == 'skipped' || '[]' }}
      needs_json: ${{ toJSON(needs) }}  # should never change

  ### CD Signal ###
  signal_deploy:
    needs: quality_gate
    if: ${{ startsWith(github.event.ref, 'refs/tags/v') }}
    uses: ./.github/workflows/_signal_deploy.yml
    with:
      main_branch: ${{ vars.GIT_MAIN_BRANCH || 'main' }}
      release_branch: ${{ vars.GIT_RELEASE_BRANCH || 'release' }}

  ### Make a Github Release ###
  gh_release:
    needs: [test, test_false, signal_deploy]
    if: always() && ( vars.OVERRIDE_DEPLOY == 'true' || ( vars.OVERRIDE_DEPLOY != 'false' && needs.signal_deploy.outputs.AUTOMATED_DEPLOY == 'true' ) )
    uses: boromir674/automated-workflows/.github/workflows/gh-release.yml@v1.13.1
    name: 'GH Release'
    with:
      tag: ${{ github.ref_name }}
      draft: ${{ needs.check_which_git_branch_we_are_on.outputs.ENVIRONMENT_NAME == 'TEST_DEPLOYMENT' }}
    secrets:
      # passing the GH_TOKEN PAT, to render in GH as ie: 'boromir674 released this yesterday', instead of 'github-actions released this yesterday'
      gh_token: ${{ secrets.GH_TOKEN_CREATE_RELEASE }}
